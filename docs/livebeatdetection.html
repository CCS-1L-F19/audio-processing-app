<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Live Beat Detection</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <style>
    body {
            background-color: rgb(30, 30, 30)
        }
    </style>
  </head>

  <body>
    <div id = "tempo_container" class = "container-fluid text-light text-center vh-25" hidden>
        <h1 class = "center m-3">Live Beat Detection</h1>
        <div class = "row">
            <div class = "col-9 h-25">
                <canvas id = "beat_canvas" class="p-3 bg-dark rounded"></canvas>
            </div>
            <div class = "col-3 vertical-center h-25">
                <h1 class = "text-dark">Tempo: </h1>
                <h3 class = "col text-light" id = "bpm"></h3>
            </div>
        </div>
    </div>
    
  </body>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

<script type="text/javascript" src = "AudioContextMonkeyPatch.js"></script>
<!-- <script type="text/javascript" src = "scales.js"></script>  -->
<script type="text/javascript">

  var myAudio = document.querySelector('audio');

  const iOSSafari = isiOSSafari();

  function isiOSSafari() {
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iP(ad|hone)/i);
    const webkit = !!ua.match(/WebKit/i);
    return iOS && webkit && !ua.match(/CriOS/i);
  }

  if (navigator.mediaDevices) {
    console.log('getUserMedia supported.');
    navigator.mediaDevices.getUserMedia ({audio: true, video: false})
    .then(function(stream) {

        // canvas init
        document.getElementById("tempo_container").hidden = false;
        var canvas = document.getElementById("beat_canvas");
        const dpr = window.devicePixelRatio || 1;
        canvas.style.width ='100%';
        canvas.style.height='100%';
        // ...then set the internal size to match
        canvas.width  = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        var ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;


        const sampleRate = 44100;
        const fftSize = 32768;
        const bufferLength = fftSize * 4 // 131072

        const channels = 1;
        const cutoffRatio = .9 // fraction of peaks within each division of length fftSize that will not be discarded
        const redrawRate = 20;

        //Haar wavelet
        const transformWavelength = 2;
        const motherWavelength = 2;
        const decompScaling = Math.SQRT1_2
        
        var audioCtx = new AudioContext();
        var source = audioCtx.createMediaStreamSource(stream);
        var analyser = audioCtx.createAnalyser();
        analyser.fftsize = fftSize;

        var peaks = [];
        var beats = [];

        var arrayBuffer = [];

        window.setInterval(update, 1000 * fftSize / sampleRate);
        window.setInterval(updateBuffer, 1000 * fftSize / sampleRate);
        // window.setInterval(redraw, 1000 / redrawRate);
        
        function update() {
            // if(iOSSafari) {
            //     var currSamples = new Uint8Array(fftSize);
            //     analyser.getByteTimeDomainData(currSamples);
            //     updatePeaks(currSamples, volThreshold * 128 + 127); // scale and shift volThreshold to account for Uint8 values
            // } else {
            //     var currSamples = new Float32Array(fftSize);
            //     analyser.getFloatTimeDomainData(currSamples);
            //     updatePeaks(currSamples, volThreshold);
            // }
            
            // beats = getBeats();
            // //drawBeats(beats);
            // const groups = getTempoGroups(beats);
            // //console.log(groups);

            // document.getElementById("bpm").innerHTML = getTempo(groups);
        }

        function updateBuffer() {
            var samples = new Float32Array(fftSize);
            analyser.getFloatTimeDomainData(samples);
            samples = Array.from(samples);
            if(arrayBuffer.length == bufferLength) { 
                arrayBuffer.splice(0, fftSize);
                arrayBuffer.push(...samples);
            }
            else {
                arrayBuffer.push(...samples);
            }
            console.log(arrayBuffer);
        }

        function tempo() {

        }

        function computeWindowTempo(samples) {
            var aC = Float32Array(); // approximation coefficients
            var dC = Float32Array(); // detail coefficients
            var dCSum = Float32Array();
            var dCMinLength = 0;
            const levels = 4;
            const maxDecimation = 2**levels-1;
            const minIndex = Math.floor(60 / 220 * sampleRate / maxDecimation);
            const maxIndex = Math.floor(60 / 40 *  sampleRate / maxDecimation);

            // 4 Level DWT
            for (var level = 0; level < levels; level++) {

                // Apply DWT
                
                if (level == 0) {
                    const coefficients = decompose(samples);
                    const l = coefficients.length - 1;
                    aC = coefficients[1].slice(0, coefficients[1].length/2);
                    dC = coefficients[l].slice(coefficients[l].length/2, coefficients[l].length);
                    dCMinLength = Math.floor(dC.length/maxDecimation) + 1
                } else {
                    const coefficients = decompose(aC);
                    const l = coefficients.length - 1
                    aC = coefficients[1].slice(0, coefficients([1].length/2));
                    dC = coefficients[l].slice(coefficients[l].length/2, coefficients[l].length);
                }

                // Extract envelope from detail coefficients
                //  1) Undersample
                //  2) Absolute value
                //  3) Subtract mean
                const pace = Math.floor(2**(levels-level-1));
                dC = Math.abs(undersample(dC, pace));
                const mean = mean(dC);
                dC.forEach((val, index) => dC[index]-= mean);

                // Recombine detail coefficients
                if (dCSum == null) {
                    dCSum = dC.slice(0, dCMinLength)
                } else {
                    dCSum = addByElement(dC.slice(0, Math.min(dCMinLength, dC.length)), dCSum);
                }
            }
        
            // Add the last approximated data
            aC = Math.abs(aC);
            const mean = mean(aC);
            aC.forEach((val, index) => aC[index]-= mean);
            dCSum = addByElement(aC.slice(0, min(dCMinLength, dC.length)), dCSum);

            // Autocorrelation
            var correlated = autocorrelate(dCSum);
            const correlatedTmp = correlated.slice(minIndex, maxIndex)

            // Detect peak in correlated data
            const location = detectPeak(correlatedTmp)

            // Compute window BPM given the peak
            const realLocation = minIndex + location
            const windowBpm = 60 / realLocation * sampleRate / maxDecimation;
            instantBpm.push(windowBpm);

        }

        // returns the location of the last positive global absolute maximum or the last global absolute maximum if there are no positive maxima
        function detectPeak(arr) {
            arr = Array.from(arr); 

            var max = -Infinity;

            arr.forEach(x => {
                if (Math.abs(x) > max) {
                    max = Math.abs(x);
                }
            });

            var index = arr.findLastIndex(max);
            if(index == -1) {
                index = arr.findLastIndex(-max);
            }

            return index;
  
        }

        // calculates the mean of an array of numbers
        function mean(arr) {
            return arr.reduce((acc, curr) => acc + curr) / arr.length; 
        }
        
        // arr2 must be at least as long as arr1
        function addByElement(arr1, arr2) {
            return arr1.map((val, index) => val + arr2[index]);
        }

        function undersample(arr, pace) {
            var newArr;
            arr.forEach((val, index) => {
                if(index % pace == 0) {
                    newArr.push(val);
                }
            });
            return newArr;
        }

        function getAutocorrelation(arr) {
          var correlated = new Array(arr.length);
          var correlationsum;
          for(var shift = 0; shift < arr.length; shift++) {
            correlationsum = 0;
            for(var i = 0; i < arr.length - shift; i++) {
                correlationsum += arr[i] * arr[i + shift];
            }
            correlated[shift] = correlationSum;
          }
          return correlated;
        }

        function decompose(samples) {
            var levels = Math.log2(samples.length) | 0; // bitwise operator converts to int
            samples.splice(2**levels); //sample length should be a power of 2 and be left intact
            var decomp = new Array(levels + 1);
            for(var p = 0; p < levels; p++) {
                decomp[p] = forward(samples, p).splice(length); // splice necessary?
            }
            return decomp;

        }

        function forward(samples, level) {
            var noOfLevels = Math.floor(Math.log2(samples.length));
            var arrHilb = Array.from(samples);

            var l = 0;
            var h = arrHilb.length;
            while( h >= transformWavelength && l < level ) {

                var arrTempPart = wavelet_forward( arrHilb, h);
                System.arraycopy( arrTempPart, 0, arrHilb, 0, h );
                h = h /= 2;
                l++;

            } // levels

            return arrHilb;

        }

        function wavelet_forward(arrTime, arrTimeLength) {
            var arrHilb = new Float32Array(arrTimeLength);
            


            var h = arrHilb.length / 2; // .. -> 8 -> 4 -> 2 .. shrinks in each step by half wavelength
            for(var i = 0; i < h; i++ ) {

                arrHilb[i] = arrHilb[i + h] = 0.; // set to zero before sum up

                for(var j = 0; j < motherWavelength; j++) {

                    var k = 2*i + j; 
                    while( k >= arrHilb.length ) {
                        k -= arrHilb.length; // circulate over arrays if scaling and wavelet are are larger
                    }
                    
                    arrHilb[i] += arrTime[k] * decompScaling; // low pass filter for the energy (approximation)
                    arrHilb[i + h] += arrTime[k] * decompScaling; // high pass filter for the details

                } // Sorting each step in patterns of: { scaling coefficients | wavelet coefficients }

            } // h = 2^(p-1) | p = { 1, 2, .., N } .. shrinks in each step by half wavelength 

            return arrHilb;
        }

        // -------------------------------
        // -------------------------------
        // -------------------------------
        // -------------------------------
        // -------------------------------
        
        function getBeats() {
            var beats = Array.from(peaks);
            // sort by volume ascending
            beats.sort((a, b) => b.vol - a.vol);
            // cut off lower volume peaks
            beats = beats.splice(0, beats.length * cutoffRatio);
            // sort by position ascending
            beats.sort((a, b) => a.pos - b.pos);
            return beats;
        }

        function updatePeaks(samples, volThreshold) {
            for(var i = 0; i < peaks.length; i++) {
                peaks[i].pos -= fftSize;
            }

            // removes peaks no longer in the buffer
            var peak = peaks[0];
            while(peaks.length > 0 && peak.pos < 0) {
                peaks.shift();
                peak = peaks[0];
            }
            
            const maxSampleIndex = samples.reduce((maxIndex, curr, currIndex, arr) => curr > arr[maxIndex] ? currIndex : maxIndex, 0);
            if(samples[maxSampleIndex] >= volThreshold) {
                peaks.push({pos: bufferLength - fftSize + maxSampleIndex, vol: samples[maxSampleIndex]});
            }
        }
        
         function redraw() {
            drawBeats(beats);
            // beats.forEach(beat => beat.pos -= (sampleRate / redrawRate))
        }

        function drawBeats(beats) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            for(var beat of beats) {
                drawLine(beat.pos / bufferLength * canvas.width);
            }
        }

        function drawLine(x) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height)
            ctx.stroke();
            ctx.closePath();
        }
    })
    .catch(function(err) {
        alert('The following getUserMedia error occured: ' + err);
        console.log('The following getUserMedia error occured: ' + err);
    });
  } else {
      alert('getUserMedia not supported on your browser!');
      console.log('getUserMedia not supported on your browser!');
    }
</script>
</html>