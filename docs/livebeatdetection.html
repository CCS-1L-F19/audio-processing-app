<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Live Beat Detection</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <style>
    body {
            background-color: rgb(30, 30, 30)
        }
    </style>
  </head>

  <body>
    <div id = "tempo_container" class = "container-fluid text-light text-center vh-25" hidden>
        <h1 class = "center m-3">Live Beat Detection</h1>
        <div class = "row">
            <div class = "col-9 h-25">
                <canvas id = "beat_canvas" class="p-3 bg-dark rounded"></canvas>
            </div>
            <div class = "col-3 vertical-center h-25">
                <h1 class = "text-dark">Tempo: </h1>
                <h3 class = "col text-light" id = "bpm"></h3>
            </div>
        </div>
    </div>
    
  </body>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

<script type="text/javascript" src = "AudioContextMonkeyPatch.js"></script>
<!-- <script type="text/javascript" src = "scales.js"></script>  -->
<script type="text/javascript">

  var myAudio = document.querySelector('audio');

  const iOSSafari = isiOSSafari();

  function isiOSSafari() {
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iP(ad|hone)/i);
    const webkit = !!ua.match(/WebKit/i);
    return iOS && webkit && !ua.match(/CriOS/i);
  }

  if (navigator.mediaDevices) {
    console.log('getUserMedia supported.');
    navigator.mediaDevices.getUserMedia ({audio: true, video: false})
    .then(function(stream) {

        // canvas init
        document.getElementById("tempo_container").hidden = false;
        var canvas = document.getElementById("beat_canvas");
        const dpr = window.devicePixelRatio || 1;
        canvas.style.width ='100%';
        canvas.style.height='100%';
        // ...then set the internal size to match
        canvas.width  = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        var ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;


        const sampleRate = 44100;
        const fftSize = 32768;
        const bufferLength = fftSize * 4; 

        const channels = 1;
        const cutoffRatio = .9 // fraction of peaks within each division of length fftSize that will not be discarded
        const redrawRate = 20;

        //Haar wavelet
        const transformWavelength = 2;
        const motherWavelength = 2;
        const decompScaling = Math.SQRT1_2

        var audioCtx = new AudioContext();
        var source = audioCtx.createMediaStreamSource(stream);
        var analyser = audioCtx.createAnalyser();
        analyser.fftSize = fftSize;

        source.connect(analyser);

        var peaks = [];
        var beats = [];

        var arrayBuffer = [];
        var tempoBuffer = [];

        window.setInterval(update, 1000 * fftSize / sampleRate);
        window.setInterval(updateBuffer, 1000 * fftSize / sampleRate);
        
        function update() {
        
            if(!tempoBuffer.length == 0) {
                document.getElementById("bpm").innerHTML = tempoBuffer[0].tempo;
            }
        }

        function updateBuffer() {
            var samples = new Float32Array(fftSize);
            analyser.getFloatTimeDomainData(samples);
            samples = Array.from(samples);
            if(arrayBuffer.length == bufferLength) { 
                arrayBuffer.splice(0, fftSize);
                arrayBuffer.push(...samples);

                computeWindowTempo(arrayBuffer);
            }
            else {
                arrayBuffer.push(...samples);
            }

            console.log(arrayBuffer);
        }


        function computeWindowTempo(samples) {
            var aC = []; // approximation coefficients
            var dC = []; // detail coefficients
            var dCSum = [];
            var dCMinLength = 0;
            const levels = 4;
            const maxDecimation = 2**(levels-1);
            const minIndex = Math.floor(60 / 200 * sampleRate / maxDecimation); // 220 = max measureable bpm
            const maxIndex = Math.floor(60 / 60 *  sampleRate / maxDecimation); // 60 = min measureable bpm

            // 4 Level DWT
            for (var level = 0; level < levels; level++) {

                // Apply DWT
                
                if (level == 0) {
                    const coefficients = decompose(samples);
                    const l = coefficients.length - 1;
                    aC = coefficients[1].slice(0, coefficients[1].length/2);
                    dC = coefficients[l].slice(coefficients[l].length/2, coefficients[l].length);
                    dCMinLength = Math.floor(dC.length/maxDecimation) + 1
                } else {
                    const coefficients = decompose(aC);
                    const l = coefficients.length - 1
                    aC = coefficients[1].slice(0, coefficients[1].length/2);
                    dC = coefficients[l].slice(coefficients[l].length/2, coefficients[l].length);
                }

                // Extract envelope from detail coefficients
                //  1) Undersample
                //  2) Absolute value
                //  3) Subtract mean
                const rate = Math.floor(2**(levels-level-1));
                dC = undersample(dC, rate);
                dC.forEach((val, index) => dC[index] = Math.abs(val));
                const mean = arrMean(dC);
                dC.forEach((val, index) => dC[index]-= mean);
                

                // Recombine detail coefficients
                if (dCSum.length == 0) {
                    dCSum = dC.slice(0, dCMinLength);
                } else {
                    dCSum = addByElement(dC.slice(0, Math.min(dCMinLength, dC.length)), dCSum);
                }
            }
        
            // Add the last approximated data
            aC.forEach((val, index) => aC[index] = Math.abs(val)); // take absolute value of all values
            const mean = arrMean(aC);
            aC.forEach((val, index) => aC[index]-= mean);
            dCSum = addByElement(aC.slice(0, Math.min(dCMinLength, dC.length)), dCSum);

            // Autocorrelation
            var correlated = getAutocorrelation(dCSum);
            const correlatedTmp = correlated.slice(minIndex, maxIndex)
            
            // Detect peak in correlated data
            const peaks = detectPeaks(correlatedTmp);
            // Compute window BPM given the peak
            peaks.forEach((peak) => {
                const realLocation = minIndex + peak.index;
                const bpm = Math.floor(60 * sampleRate / (realLocation * maxDecimation));
                var existingGroup = tempoBuffer.find(group => Math.abs(group.tempo - bpm) <= 1);
                if(existingGroup) {
                    existingGroup.count++;
                } else {
                    tempoBuffer.push({tempo: bpm, count: 1});
                }
            });
            
            tempoBuffer.sort((a,b) => b.count - a.count);
            console.log(tempoBuffer);
            console.log(tempoBuffer[0])

        }

        function detectPeaks(arr) {
            //console.log(arr);
            arr = Array.from(arr); 
            arr.forEach((val, index) => arr[index] = Math.abs(val));

            const chunkLength = Math.floor(arr.length / 10);

            var maxima = [];
            for(var i = 0; i < 10; i++) {
                const chunk = arr.slice(i * chunkLength, (i + 1) * chunkLength);
                const max = Math.max(...chunk);
                maxima.push({index: chunkLength * i + chunk.indexOf(max), value: max});
            }
            maxima = maxima.sort((a, b) => b.value - a.value).slice(0, 3);
            console.log(maxima)
            return maxima

            // var max = -Infinity;

            // arr.forEach(x => {
            //     if (Math.abs(x) > max) {
            //         max = Math.abs(x);
            //     }
            // });
            
            // var index = arr.indexOf(max);
            // if(index == -1) {
            //     index = arr.indexOf(-max);
            // }
            // console.log("max: " + max);
            // return index;

        }

        function decompose(samples) {
            var levels = Math.floor(Math.log2(samples.length));
            samples.splice(2**levels); //sample length should be a power of 2 and be left intact
            var decomp = new Array(levels + 1);
            for(var p = 0; p <= levels; p++) {
                decomp[p] = forward(samples, p).splice(length); // splice necessary?
            }
            return decomp;

        }

        function forward(samples, level) {
            var noOfLevels = Math.floor(Math.log2(samples.length));
            var arrHilb = Array.from(samples);

            var l = 0;
            var h = arrHilb.length;
            while( h >= transformWavelength && l < level ) {

                var arrTempPart = wavelet_forward(arrHilb, h);
                arrTempPart = arrTempPart.slice(0, h);
                arrHilb = arrTempPart.concat(arrHilb.slice(h)); 
                //System.arraycopy( arrTempPart, 0, arrHilb, 0, h );
                h /= 2;
                l++;
            } 

            return arrHilb;

        }

        function wavelet_forward(arrTime, arrTimeLength) {
            var arrHilb = new Float32Array(arrTimeLength);

            var h = arrHilb.length / 2; // .. -> 8 -> 4 -> 2 .. shrinks in each step by half wavelength
            for(var i = 0; i < h; i++ ) {

                arrHilb[i] = arrHilb[i + h] = 0.; // set to zero before sum up

                for(var j = 0; j < motherWavelength; j++) {

                    var k = 2*i + j; 
                    while( k >= arrHilb.length ) {
                        k -= arrHilb.length; // circulate over arrays if scaling and wavelet are are larger
                    }
                    
                    arrHilb[i] += arrTime[k] * decompScaling; // low pass filter for the energy (approximation)
                    arrHilb[i + h] += arrTime[k] * decompScaling; // high pass filter for the details

                } // Sorting each step in patterns of: { scaling coefficients | wavelet coefficients }

            } // h = 2^(p-1) | p = { 1, 2, .., N } .. shrinks in each step by half wavelength 

            return Array.from(arrHilb);
        }

        // calculates the mean of an array of numbers
        function arrMean(arr) {
            return arr.reduce((acc, curr) => acc + curr) / arr.length; 
        }
        
        // arr2 must be at least as long as arr1
        function addByElement(arr1, arr2) {
            return arr1.map((val, index) => val + arr2[index]);
        }

        function undersample(arr, rate) {
            var newArr = [];
            arr.forEach((val, index) => {
                if(index % rate == 0) {
                    newArr.push(val);
                }
            });
            return newArr;
        }

        function getAutocorrelation(arr) {
          var correlated = new Float32Array(arr.length);
          var correlationSum;
          for(var shift = 0; shift < arr.length; shift++) {
            correlationSum = 0;
            for(var i = 0; i < arr.length - shift; i++) {
                correlationSum += arr[i] * arr[i + shift];
            }
            correlated[shift] = correlationSum;
          }
          return correlated;
        }
        
    })
    .catch(function(err) {
        console.log('The following getUserMedia error occured: ' + err);
    });
  } else {
      alert('getUserMedia not supported on your browser!');
      console.log('getUserMedia not supported on your browser!');
    }
</script>
</html>